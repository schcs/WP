{"id":773,"date":"2020-08-12T19:12:56","date_gmt":"2020-08-12T19:12:56","guid":{"rendered":"http:\/\/localhost\/?page_id=773"},"modified":"2022-04-28T09:03:29","modified_gmt":"2022-04-28T12:03:29","slug":"o-algoritmo-de-euclides","status":"publish","type":"page","link":"http:\/\/localhost\/index.php\/ensino\/algebra-a\/o-algoritmo-de-euclides\/","title":{"rendered":"O algoritmo de Euclides"},"content":{"rendered":"<div style=\"color: #000000;\">\nSejam $a,b\\in\\N_0$ com $b&lt;a$. O resultado provado no final da p\u00e1gina anterior sugere o seguinte processo recursivo para calcular o $\\mbox{mdc}(a,b)$:<\/p>\n<p>\n<strong>Passo 1:<\/strong> Se $b=0$, ent\u00e3o $\\mdc ab=a$.<br \/>\n<strong>Passo 2:<\/strong> Se $b \\neq 0$ ent\u00e3o use o Teorema de Divis\u00e3o de Euclides para escrever $a=qb+r$ com $r\\in\\{0,\\ldots,b-1\\}$. <br \/>\n<strong>Passo 3:<\/strong> $\\mdc ab=\\mdc br$.\n<\/p>\n<p>O processo funciona, pois no Passo 3., os n\u00fameros $b$ e $r$ s\u00e3o menores que $a$ e $b$. Logo, mais cedo ou mais tarde, o processo vai chegar at\u00e9 uma situa\u00e7\u00e3o quando $b=0$ e neste caso o valor do $\\mdc ab$ ser\u00e1 igual a $a$ pelo Passo 1. Veja o exemplo na p\u00e1gina anterior para uma computa\u00e7\u00e3o detalhada seguindo este processo.<\/p>\n<p>Este algoritmo pode ser implementado em Julia com a seguinte fun\u00e7\u00e3o recursiva.<\/p>\n<pre><code class=\"language-python\">\nfunction MDC_recursivo( a, b )\n            \n    if b == 0\n        return a\n    else\n        return MDC_recursivo( b, a % b )\n\tend\nend\n<\/code><\/pre>\n<p>Para melhor analisarmos o algoritmo, n\u00f3s escrevemos o processo em uma maneira linear (n\u00e3o recursiva). O processo descrito abaixo \u00e9 chamado Algoritmo de Euclides. Sejam $a,b$ como acima.<br \/>\n\\[<br \/>\n\\begin{align*}<br \/>\nr_{-1}&#038;=a\\\\<br \/>\nr_0&#038;=b\\\\<br \/>\na=r_{-1}&amp;=q_1b+r_1\\quad 0&lt;r_1&lt;b\\\\<br \/>\nb=r_0&amp;=q_2r_1+r_2\\quad 0&lt;r_2&lt;r_1\\\\<br \/>\nr_1&amp;=q_3r_2+r_3\\quad 0&lt;r_3&lt;r_2\\\\<br \/>\n&amp;\\vdots\\\\<br \/>\nr_{i-1}&amp;=q_{i+1}r_{i}+r_{i+1}\\quad 0&lt;r_{i+1}&lt;r_{i}\\\\<br \/>\nr_{i}&amp;=q_{i+2}r_{i+1}+r_{i+2}\\quad 0&lt;r_{i+2}&lt;r_{i+1}\\\\<br \/>\n&amp;\\vdots\\\\<br \/>\nr_{d-2}&amp;=q_{d}r_{d-1}+r_{d}\\quad 0&lt;r_{d}&lt;r_{d-1}\\\\<br \/>\nr_{d-1}&amp;=q_{d+1}r_d+0<br \/>\n\\end{align*}<br \/>\n\\]<\/p>\n<p>A sequ\u00eancia dos restos calculados satisfaz as desigualdades<br \/>\n\\[<br \/>\na&gt;b&gt;r_1&gt;r_2&gt;\\cdots&gt;r_i&gt;\\cdots&gt;r_d&gt;r_{d+1}=0.<br \/>\n\\]<br \/>\nEm outras palavras, a sequ\u00eancia dos restos \u00e9 uma sequ\u00eancia decrescente de n\u00fameros positivos. Note que tal sequ\u00eancia sempre atinge o n\u00famero zero em um n\u00famero finitos de passos; ou seja, existe algum $d$ tal que $r_{d+1}=0$. Pelo racioc\u00ednio acima, obtemos que<br \/>\n\\begin{align*}<br \/>\n\\mdc ab&#038;=\\mdc b{r_1}=\\mdc{r_1}{r_2}=\\cdots=\\mdc{r_i}{r_{i+1}}=\\cdots\\\\&#038;=\\mdc{r_{d-1}}{r_d}=\\mdc{r_d}0=r_d.<br \/>\n\\end{align*}<\/p>\n<p>Isso justifica o seguinte resultado.<\/p>\n<div class=\"lemma\">Se $a,b\\in \\N_0$ tais que $b\\neq 0$, ent\u00e3o o \u00faltimo resto n\u00e3o nulo $r_d$ calculado pelo Algoritmo de Euclides \u00e9 igual a $\\mdc ab$. O algoritmo termina depois de um n\u00famero finito de passos.\n<\/div>\n<p>Note que nos resultados acima, n\u00f3s assumimos que $a,b$ s\u00e3o n\u00fameros n\u00e3o negativos. No entanto, o procedimento pode ser usado mesmo quando $a$ ou $b$ (ou os dois) s\u00e3o negativos, pois neste caso, simplesmente podemos trocar o n\u00famero negativo pelo seu sim\u00e9trico (que vai ser positivo) pelo fato que $\\mdc ab=\\mdc{\\pm a}{\\pm b}$. <\/p>\n<p>Em particular n\u00f3s finalmente conseguimos concluir o seguinte resultado sobre a exist\u00eancia do $\\mdc ab$.<\/p>\n<div class=\"corollary\">\nSe $a,b\\in\\Z$ tais que $(a,b)\\neq (0,0)$, ent\u00e3o existe $\\mdc ab$.\n<\/div>\n<p>O procedimento acima pode tamb\u00e9m ser implementado em Julia com a seguinte fun\u00e7\u00e3o.<\/p>\n<pre><code class=\"language-python\">\nfunction MDC(a,b)\n\n    while b != 0\n        a, b = b, a % b  \n\tend\n    return a\nend\n<\/code>\r\n<\/pre>\n<p>Uma outra consequ\u00eancia do Algoritmo de Euclides \u00e9 o seguinte resultado extremamente \u00fatil e bem conhecido.<\/p>\n<div class=\"theorem\">\nSejam $a,b\\in\\Z$ com $(a,b)\\neq 0$. Ent\u00e3o existem $u,v\\in\\Z$ tais que<br \/>\n\\[<br \/>\n\\mdc ab=ua+vb.<br \/>\n\\]<br \/>\nEm particular, se $a$ e $b$ s\u00e3o primos entre si, ent\u00e3o existem $u,v\\in\\Z$ tais que<br \/>\n\\[<br \/>\n1=ua+vb.<br \/>\n\\]\n<\/div>\n<div class=\"proof\">\nN\u00f3s podemos assumir sem perda de generalidade que $0&lt;b&lt;a$. Com esta suposi\u00e7\u00e3o, podemos executar o algoritmo de Euclides para $a$ e $b$. <\/p>\n<p>Afirmamos que, para todo $i\\geq 1$, o resto $r_i$ pode ser escrito como $u_ia+v_ib$ com coeficientes $u_i,v_i\\in\\Z$. Verificaremos a afirma\u00e7\u00e3o por indu\u00e7\u00e3o em $i$. A afirma\u00e7\u00e3o est\u00e1 verdadeira para $i=1$, pois<br \/>\n\\[<br \/>\nr_1=a-q_1b\\quad\\text{e assim}\\quad u_1=1,\\ v_1=-q_1.<br \/>\n\\]<br \/>\nAssuma que $i\\geq 1$ e, para $j\\leq i$ existem $u_j,v_j\\in \\Z$ tais que<br \/>\n\\[<br \/>\nr_j=u_ja+v_jb.<br \/>\n\\]<br \/>\nOra, segue da equa\u00e7\u00e3o para $r_{i-1}$ que<br \/>\n\\begin{align*}<br \/>\nr_{i+1}&#038;=r_{i-1}-q_{i+1}r_{i}=u_{i-1}a+v_{i-1}b-q_{i+1}(u_{i}a+v_{i}b)\\\\&#038;=<br \/>\n(u_{i-1}-q_{i+1}u_i)a+(v_{i-1}-q_{i+1}v_i)b.<br \/>\n\\end{align*}<br \/>\nOu seja, podemos tomar<br \/>\n\\[<br \/>\nu_{i+1}=u_{i-1}-q_{i+1}u_i\\quad\\mbox{e}\\quad v_{i+1}=v_{i-1}-q_{i+1}v_i.<br \/>\n\\] <\/p>\n<p>Agora, temos que<br \/>\n\\[<br \/>\n\\mdc ab=r_d=u_da+v_db<br \/>\n\\]<br \/>\ne o teorema est\u00e1 v\u00e1lido com $u=u_d$ e $v=v_d$.\n<\/p><\/div>\n<p>Note que a demonstra\u00e7\u00e3o acima d\u00e1 um algoritmo para calcular os coeficientes $u,v$ e este algoritmo pode ser executado em paralelo com a computa\u00e7\u00e3o do $\\mdc ab$. O algoritmo que calcula o $\\mdc ab$  junto com os coeficientes $u,v$ tais que<br \/>\n\\[<br \/>\n\\mdc ab=ua+vb<br \/>\n\\]<br \/>\n\u00e9 geralmente chamado Algoritmo Estendido de Euclides. A seguinte \u00e9 uma implementa\u00e7\u00e3o simples do Algoritmo Estendido em Julia.<\/p>\n<pre>\r\n<code class=\"language-python\">\n#algoritmo extendido de Euclides\nfunction XMDC(a,b)\n    x0, x = 1, 0; y0, y = 0, 1\n           \n    while b&gt;0 \n        q, r = a \u00f7 b, a%b\n        a, b = b, r\n        \n        #atualizar x, x0, y, y0\n        x, x0 = x0 - q*x, x\n        y, y0 = y0 - q*y, y\n    end \n    \n    return a, x0, y0\nend\n<\/code>\r\n<\/pre>\n<p>Para verificarmos que o algoritmos de Euclides \u00e9 um algoritmo pr\u00e1tico, precisamos dar uma estimativa para o n\u00famero dos passos do que ele precisa; ou seja, precisamos limitar o n\u00famero $d$.<\/p>\n<p>A sequ\u00eancia de Fibonacci \u00e9 definida com a seguinte regra. Tomemos $F_0=F_1=1$, e para $i\\geq 2$, definimos $F_i=F_{i-1}+F_{i-2}$. Os termos da sequ\u00eancia s\u00e3o $1,1,2,3,5,8,13,21,34,\\ldots$<\/p>\n<p>Denote $\\varphi$ o n\u00famero $(1+\\sqrt 5)\/2$ (<a href=\"https:\/\/pt.wikipedia.org\/wiki\/Propor%C3%A7%C3%A3o_%C3%A1urea\">n\u00famero \u00e1ureo<\/a>).<\/p>\n<div class=\"exercise\">\u00a0<br \/>\nMostre, para $i\\geq 1$, que $\\varphi^{i-1}\\leq F_i\\leq\\varphi^i$.\n<\/div>\n<div class=\"theorem\">\nSeja $d$ o n\u00famero de passos que precisamos para executar o Algoritmo de Euclides para os n\u00fameros $a$ e $b$ como acima. Ent\u00e3o $d\\leq \\log b\/\\log \\varphi$.\n<\/div>\n<div class=\"proof\">\u00a0<br \/>\nPonha $r_{-1}=a$, $r_0=b$, e seja $r_1,\\ldots,r_{d}$ a sequ\u00eancia dos restos na computa\u00e7\u00e3o acima. Defina $u_1=r_d$, $u_2=r_{d-1}$, $u_3=r_{d-2},\\ldots,u_{d-1}=r_{2}$, $u_{d}=r_1$, $u_{d+1}=r_0=b$, $u_{d+2}=r_{-1}=a$.<\/p>\n<p><em>Afirma\u00e7\u00e3o.<\/em>\u00a0$u_i\\geq F_i$. Provamos a afirma\u00e7\u00e3o por indu\u00e7\u00e3o em $i$. De fato, temos que $u_1\\geq F_1=1$ e $u_2\\geq F_2=2$. Se $i\\geq 3$, ent\u00e3o considere a equa\u00e7\u00e3o<br \/>\n\\begin{eqnarray*}<br \/>\nu_i&amp;=&amp;r_{d-i+1}=r_{d-i+2}q_{d-i+2}+r_{d-i+3}\\geq r_{d-i+2}+r_{d-i+3}\\\\&amp;=&amp;u_{i-1}+u_{i-2}\\geq F_{i-1}+F_{i-2}=F_i.<br \/>\n\\end{eqnarray*}<br \/>\nCombinando esta conta com o exerc\u00edcio anterior, obtemos que<br \/>\n\\[<br \/>\nu_i\\geq F_i\\geq \\varphi^{i-1}\\quad\\mbox{para todo}\\quad i\\geq 1.<br \/>\n\\]<br \/>\nEm particular $b=u_{d+1}\\geq \\varphi^{d}$. Tomando o logaritmo isso implica que $\\log_{\\varphi}b\\geq d$. Passando para o logaritmo natural, tem-se que<br \/>\n\\[<br \/>\nd\\leq \\frac{\\log b}{\\log\\varphi}<br \/>\n\\]\n<\/div>\n<p>O resultado anterior implica que o n\u00famero de passos no Algoritmo de Euclides \u00e9 limitado por uma fun\u00e7\u00e3o logar\u00edtmica em $b$ que quer dizer que o Algoritmo de Euclides \u00e9 um algoritmo pr\u00e1tico.\n<\/p><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Sejam $a,b\\in\\N_0$ com $b&lt;a$. O resultado provado no final da p\u00e1gina anterior sugere o seguinte processo recursivo para calcular o $\\mbox{mdc}(a,b)$: Passo 1: Se $b=0$, ent\u00e3o $\\mdc ab=a$. Passo 2: Se $b \\neq 0$ ent\u00e3o use o Teorema de Divis\u00e3o de Euclides para escrever $a=qb+r$ com $r\\in\\{0,\\ldots,b-1\\}$. Passo 3: $\\mdc ab=\\mdc br$. O processo funciona, &hellip; <a href=\"http:\/\/localhost\/index.php\/ensino\/algebra-a\/o-algoritmo-de-euclides\/\" class=\"more-link\">Continue reading <span class=\"screen-reader-text\">O algoritmo de Euclides<\/span><\/a><\/p>\n","protected":false},"author":1,"featured_media":0,"parent":706,"menu_order":0,"comment_status":"closed","ping_status":"closed","template":"","meta":[],"_links":{"self":[{"href":"http:\/\/localhost\/index.php\/wp-json\/wp\/v2\/pages\/773"}],"collection":[{"href":"http:\/\/localhost\/index.php\/wp-json\/wp\/v2\/pages"}],"about":[{"href":"http:\/\/localhost\/index.php\/wp-json\/wp\/v2\/types\/page"}],"author":[{"embeddable":true,"href":"http:\/\/localhost\/index.php\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"http:\/\/localhost\/index.php\/wp-json\/wp\/v2\/comments?post=773"}],"version-history":[{"count":9,"href":"http:\/\/localhost\/index.php\/wp-json\/wp\/v2\/pages\/773\/revisions"}],"predecessor-version":[{"id":1764,"href":"http:\/\/localhost\/index.php\/wp-json\/wp\/v2\/pages\/773\/revisions\/1764"}],"up":[{"embeddable":true,"href":"http:\/\/localhost\/index.php\/wp-json\/wp\/v2\/pages\/706"}],"wp:attachment":[{"href":"http:\/\/localhost\/index.php\/wp-json\/wp\/v2\/media?parent=773"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}